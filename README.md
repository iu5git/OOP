# 1 - Создание и использование статической библиотеки <!-- omit in toc -->

> Лабораторная работа 1 для студентов курса "Программирование на основе классов и шаблонов" 2 семестра кафедры ИУ5 МГТУ им Н.Э. Баумана.

## Содержание <!-- omit in toc -->

- [Цель работы](#цель-работы)
- [Начало работы](#начало-работы)
- [Задание](#задание)
    - [Основное задание](#основное-задание)
    - [Дополнительные задания (по вариантам)](#дополнительные-задания-по-вариантам)
- [Требования к отчёту](#требования-к-отчёту)
- [Вопросы для защиты](#вопросы-для-защиты)

## Цель работы

Целью лабораторной работы является формирование у студентов практических навыков проектирования и использования статических библиотек на языке программирования C++ с применением системы автоматизации сборки CMake, а также освоение принципов разработки кроссплатформенных программных приложений.

В ходе выполнения лабораторной работы студенты должны закрепить знания по модульной организации программного кода и компоновке программных проектов.

## Начало работы

Зайдите в свою локальную директорию с репозиторием для выполнения лабораторных работ. Заберите ветку с соответствующей лабораторной работой из общего репозитория:

```sh
git pull upstream
```

**или**

```sh
git pull upstream lab_1
```

Переключитесь на ветку с текущей лабораторной работой:

```sh
git checkout lab_1
```

Свяжите ветку локального репозитория с вашим удаленным репозиторием:

```sh
git push --set-upstream origin lab_1
```

## Задание

#### Основное задание

В рамках лабораторной работы необходимо:

- Создать проект статической библиотеки с использованием системы сборки CMake.

- Реализовать в библиотеке набор функций или класс, обеспечивающий заданную функциональность.

- Создать консольное приложение на языке C++, использующее разработанную статическую библиотеку.

- Подключить библиотеку к приложению и продемонстрировать корректность её работы.

- Обеспечить возможность сборки и запуска проекта в операционных системах семейства Linux.

#### Дополнительные задания (по вариантам)

*Вариант 1*
Добавить в библиотеку функцию вычитания чисел и продемонстрировать её использование в основном приложении.

*Вариант 2*
Реализовать в библиотеке операции умножения и деления. Предусмотреть обработку деления на ноль.

*Вариант 3*
Создать библиотеку утилит для обработки аргументов командной строки.

*Вариант 4*
Реализовать в библиотеке функции для работы с массивом чисел (поиск минимального, максимального значения и вычисление среднего).

*Вариант 5*
Добавить в библиотеку функцию возведения числа в степень без использования стандартных библиотечных функций.

*Вариант 6*
Реализовать функции для генерации псевдослучайных чисел и заполнения ими массива.

*Вариант 7*
Реализовать в библиотеке функции для вычисления факториала.

*Вариант 8*
Создать библиотеку для работы со строками (конкатенация, определение длины строки) без использования стандартных библиотечных функций.

*Вариант 9*
Реализовать в библиотеке функции для сортировки массива целых чисел.

*Вариант 10*
Добавить в библиотеку функции для поиска элемента в массиве (линейный поиск).

*Вариант 11*
Реализовать библиотеку для работы с датами (сравнение дат, вычисление разницы между датами).

*Вариант 12*
Создать библиотеку для работы с геометрическими фигурами (вычисление площади и периметра).

*Вариант 13*
Реализовать функции для перевода целых чисел из одной системы счисления в другую.

*Вариант 14*
Создать библиотеку утилит для обработки аргументов командной строки.

*Вариант 15*
Реализовать библиотеку вспомогательных функций для работы с файлами (чтение и запись текстовых данных).

*Вариант 16*
Добавить в библиотеку функции для вычисления наибольшего общего делителя и наименьшего общего кратного двух чисел.

*Вариант 17*
Добавить в библиотеку функции для проверки числа на простоту и разложения числа на простые множители.

*Вариант 18*
Создать библиотеку для статистической обработки данных (среднее значение, медиана, дисперсия).

## Требования к отчёту

Отчёт по лабораторной работе должен содержать:

- Титульный лист с указанием дисциплины, номера лабораторной работы, ФИО студента и группы.

- Цель лабораторной работы.

- Формулировку задания и номер варианта.

- Краткие теоретические сведения по теме работы.

- Описание структуры проекта и используемых файлов.

- Исходный код разработанной статической библиотеки и основного приложения.

- Результаты выполнения программы (скриншоты или вывод в консоль).

- Выводы по результатам выполненной работы.

<!-- Критерии оценки

Оценка лабораторной работы осуществляется по следующим критериям:

корректность сборки проекта с использованием CMake;

правильность создания и подключения статической библиотеки;

соответствие реализованного функционала заданию и варианту;

корректность и читаемость исходного кода;

возможность сборки и запуска проекта в ОС семейства Linux;

полнота и аккуратность оформления отчёта.
-->
## Вопросы для защиты

- Что такое статическая библиотека и в чём её назначение?

- В чём различие между статическими и динамическими библиотеками?

- На каком этапе происходит подключение статической библиотеки к программе?

- Назначение файлов заголовков в библиотеке.

- Основные команды CMake для создания библиотек и исполняемых файлов.

- Для чего используется команда target_link_libraries?

- Преимущества и недостатки статических библиотек.

- Что означает кроссплатформенность программного обеспечения?

<!--
## Указания по выполнению лабораторной работы

### Разработка кроссплатформенных приложений

При выполнении заданий лабораторных работ дисциплины обязательным условием использование современных интегрированных сред разработки таких, как Visual Studio Code и CLion. Данные среды позволяют разрабатывать кроссплатформенные приложения на языке C++.

Также обязательным требованием к создаваемым программ по заданиям лабораторных работ является наличие возможности их запуска в операционных системах семейства Linux.

### Введение

Создаваемое решение содержит исходные коды включаемых в библиотеку классов и в дальнейшем может использоваться как "мастерская" для расширения библиотеки и внесения в неё изменений. Решение включает в себя два проекта: первый будем использовать для создания статической библиотеки (тип проекта – `library`), а второй будем использовать для тестирования созданной библиотеки (тип проекта – `executable`).

В пошаговом руководстве по созданию статической библиотеки описывается создание статической библиотеки с помощью CMake для использования с приложениями C++.

Статические библиотеки являются хорошим способом повторного использования кода. Вместо повторного включения одних и тех же процедур в каждое приложение, требуемые функции объединяются в статическую библиотеку и затем выполняется ссылка на этот файл из приложений. Код, связанный со статической библиотекой, становится частью вашего приложения и вам не нужно создавать другой файл для использования кода функций. -->

<!-- Исходная точка

Давайте рассмотрим проект, в котором рекомендуется вести разработку лабораторных работ.

Папка проекта выглядит следующим образом:

labs

├─ lab1

│ ├─ CMakeList.txt

│ ├─ README.md

│ └─ main.cpp

├── lab2
...
└── lab9

Последовательно разберемся с тем, что содержится в папке:

• CMakeList.txt - это мы будем трогать и изучать подробнее далее.
• README.md - описание решения в формате Markdown. Если вы не знаете о Markdown, то рекомендуется это исправить.
• main.cpp - точка входа в нашу программу.
Давайте теперь разбираться с тем, что содержит сейчас CMakeList.txt.


Описание CMakeList.txt
-->

<!--В CMakeList.txt содержится следующее:

``` cpp
cmake_minimum_required(VERSION 3.23)
project(lab1)

set(CMAKE_CXX_STANDARD 17)

add_executable(lab1 main.cpp)

IF (NOT WIN32)
target_link_libraries(lab1 m)
ENDIF()
cmake_minimum_required
```

Команда cmake_minimum_required проверяет запущенную версию CMake: если она меньше указанного минимума, то CMake завершает свою работу фатальной ошибкой.

project

В начале любого CMakeLists.txt следует задать характеристики проекта командой project для лучшего оформления интегрированными средами и прочими инструментами разработки.

Вызывать эту функцию рекомендуется по умолчанию, так как она позволит инициализировать сборщик и переменные окружения.

ПРЕДУПРЕЖДЕНИЕ
Название проекта у вас должно обязательно совпадать с названием директории для лабораторной работы. В противном случае у вас будет ломаться конвейер проверки кода на запросе при слиянии.
set(CMAKE_CXX_STANDARD 17)

Этой функцией вы устанавливаете требование определенного языкового стандарта - C++ 17.

Это требование можно установить различным образом. Но здесь это сделано именно так.

add_executable

Команда add_executable компилирует исполняемый файл с заданным именем из списка исходников. Важно отметить, что окончательное имя файла зависит от целевой платформы (например, <ExecutableName>.exe или просто <ExecutableName>).

IF-ENDIF

CMake - очень мощная штука (а под капотом вообще магическая штука). CMake - не компилирует программы! CMake подготавливает среду, чтобы уже другие средства, например, MSBuild, Ninja и Make, уже собрали приложения. Иными словами, CMake не занимается непосредственно сборкой, а лишь генерирует файлы сборки из предварительно написанного файла сценария CMakeLists.txt и предоставляет простой единый интерфейс управления.

CMake имеет множество встроенных средств, позволяющих определить то, на какой платформе он работает, и найти запрашиваемые библиотеки для линковки (компановка объектных файлов и библиотек).

И если мы начинаем говорить про кроссплатформенность, то без конструкций условия никуда не деться.

На платформе WIN32 требуется явно скомпоновать математическую библиотеку math.h и проект, в котором мы хотим использовать ее. Делается это с помощью команды target_link_libraries. Она компонует библиотеку или исполняемый файл с другими предоставляемыми библиотеками. Первым аргументом данная команда принимает название цели, сгенерированной с помощью команд add_executable или add_library, а последующие аргументы представляют собой названия целей библиотек или полные пути к библиотекам.

### Создание статической библиотеки

>К СВЕДЕНИЮ
Материал для подготовки взят с A.1 – Статические и динамические библиотеки.https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/

Библиотека
Библиотека – это пакет кода, который предназначен для повторного использования многими программами. Обычно библиотека C++ состоит из двух частей:

1. заголовочный файл, который определяет функциональность, которую библиотека предоставляет (предлагает) программам, использующим ее;
2. предварительно скомпилированный двоичный файл, который содержит реализацию этой функциональности, предварительно скомпилированную в машинный код.
Некоторые библиотеки могут быть разделены на несколько файлов и/или иметь несколько файлов заголовков.

Библиотеки предварительно скомпилированы по нескольким причинам:

1. Во-первых, поскольку библиотеки меняются редко, их не нужно часто перекомпилировать. Было бы пустой тратой времени перекомпилировать библиотеку каждый раз, когда вы пишете программу, которая ее использует.
2. Во-вторых, поскольку предварительно скомпилированные объекты представлены машинным кодом, люди не могут получить доступ к исходному коду или изменить его, что важно для предприятий или людей, которые не хотят делать свой исходный код доступным из соображений интеллектуальной собственности.
Существует два типа библиотек: статические библиотеки и динамические библиотеки.

Статическая библиотека
Статическая библиотека (иногда называемая archive, "архив") состоит из подпрограмм, которые скомпилированы и линкуются непосредственно с вашей программой. Когда вы компилируете программу, использующую статическую библиотеку, все функции статической библиотеки, которые использует ваша программа, становятся частью вашего исполняемого файла. В Windows статические библиотеки обычно имеют расширение .lib, а в Linux – расширение .a (archive, архив).

Одним из преимуществ статических библиотек является то, что вам нужно распространять только исполняемый файл, чтобы пользователи могли запускать вашу программу. Поскольку библиотека становится частью вашей программы, это гарантирует, что с вашей программой всегда будет использоваться правильная версия библиотеки. Кроме того, поскольку статические библиотеки становятся частью вашей программы, вы можете использовать их так же, как функции, которые вы написали для своей программы. С другой стороны, поскольку копия библиотеки становится частью каждого исполняемого файла, который ее использует, это может привести к потере большого количества места. Статические библиотеки также не могут быть легко обновлены – для обновления библиотеки необходимо заменить весь исполняемый файл.

Динамическая библиотека
Динамическая библиотека (также называемая shared library, "общая библиотека") состоит из подпрограмм, которые загружаются в ваше приложение во время выполнения. Когда вы компилируете программу, использующую динамическую библиотеку, библиотека не становится частью вашего исполняемого файла – она ​​остается отдельной единицей. В Windows динамические библиотеки обычно имеют расширение .dll (dynamic link library, библиотека динамической компоновки), а в Linux – расширение .so (shared object, общий объект).

Одним из преимуществ динамических библиотек является то, что многие программы могут совместно использовать одну копию библиотеки, что экономит место. Возможно, большим преимуществом является то, что динамическую библиотеку можно обновить до более новой версии без замены всех исполняемых файлов, которые ее используют.

Поскольку динамические библиотеки не связаны с вашей программой, программы, использующие динамические библиотеки, должны явно загружать и взаимодействовать с динамической библиотекой. Этот механизм может сбивать с толку и затруднять взаимодействие с динамической библиотекой. Чтобы упростить использование динамических библиотек, можно использовать библиотеку импорта.

Библиотека импорта
Библиотека импорта – это библиотека, которая автоматизирует процесс загрузки и использования динамической библиотеки. В Windows это обычно делается с помощью небольшой статической библиотеки (.lib) с тем же именем, что и динамическая библиотека (.dll). Статическая библиотека подключается к программе во время компиляции, и затем функциональные возможности динамической библиотеки можно эффективно использовать, как если бы это была статическая библиотека. В Linux файл общих объектов (.so) выполняет функции динамической библиотеки и библиотеки импорта. Большинство компоновщиков при создании динамической библиотеки могут создать библиотеку импорта для этой динамической библиотеки.

И как это применить к нашему проекту?
При выполнении лабораторных работ от вас будут требовать декомпозировать ваш код на связанные логические модули и представлять их виде библиотек. Эти библиотеки необходимо будет располагать в директории лабораторной работы, задание которой вы выполняете. Поэтому для наших целей будет подходить создание статической библиотеки.

Давайте на примере обычной библиотеки, умеющей только складывать несколько чисел, рассмотрим, как делать статические библиотеки для выполнения лабораторных работ.

### Создание проекта статической библиотеки

В директории создадим поддиректорию mymath.

В ней создадим файлы CMakeLists.txt, mymath.cpp и mymath.h. В итоге наша директория с лабораторной работой будет выглядеть следующим образом:

lab1
├── mymath
│   ├── CMakeLists.txt
│   ├── mymath.cpp
│   └── mymath.h
├── tests
├── CMakeList.txt
├── README.md
└── main.cpp
Содержимое mymath.cpp

Оставляем код без комментариев:
``` cpp
#include "mymath.h"

namespace mymath {
   int sum(int a, int b) {
       return a + b;
   }
}
```

Содержимое mymath.h
``` cpp
#ifndef MYMATH_H
#define MYMATH_H

namespace mymath {
   int sum(int a, int b);
}

#endif //MYMATH_H
```

>К СВЕДЕНИЮ
`#ifndef` - это про include guard:

Как только заголовок включен, он проверяет, определено ли уникальное значение. Затем, если он не определен, он определяет его и переходит к остальной части кода.

Когда код включается снова, первый #ifndef завершается ошибкой, в результате чего получается пустой файл.

Это предотвращает двойное объявление любых идентификаторов, таких как типы, перечисления и статические переменные.
И CMakeLists.txt
``` cpp
cmake_minimum_required(VERSION 3.23)

set(project "mymath")
project(${project})

set(CMAKE_CXX_STANDARD 17)

set(${project}_SOURCES
       mymath.cpp)

set(${project}_HEADERS
       mymath.h)

set(${project}_SOURCE_LIST
       ${${project}_SOURCES}
       ${${project}_HEADERS})

add_library(${project}
       STATIC
       ${${project}_SOURCE_LIST})
```

Тут явно решили выделить название проекта в отдельную переменную окружения CMake с помощью вызова функции set(project "mymath").

Переменные можно определить путём вызова команды set, а удалить вызовом unset. Получить значение переменной можно по конструкции ${VARIABLE}. Если переменная ещё не определена и где-то потребовалось получить её значение, то данная переменная обратится в пустую строку.

Далее мы устанавливаем переменные окружения ${project}_HEADERS, ${project}_SOURCES и ${project}_SOURCE_LIST. Тут явное перечисление то, какие исходные файлы и заголовочные файлы мы подключаем. Если мы добавляем новый файл, то нам явно нужно переписать CMakeLists.txt, а он в свою очередь начнет перегенировать свой проект.

Команда add_library компилирует библиотеку с указанным видом и именем из исходников. Важно отметить, что окончательное имя библиотеки зависит от целевой платформы (например, lib<LibraryName>.a или <LibraryName>.lib).

О том, зачем указывать в add_library и add_executable в заголовочных файлах в CMake-файлах, пояснили тут.

Ну вот и все! Остается эту библиотеку подключить к нашему консольному приложению.

Использование статической библиотеки
Обновление CMakeLists.txt главного проекта
Давайте теперь сообщим CMake о том, что у нас в директории содержится статическая библиотека. Для этого изменим CMakeLists.txt главного проекта (лежащий в корне директории lab1) следующим образом:

```cpp
cmake_minimum_required(VERSION 3.23)

set(project "lab1")
project(${project})

set(CMAKE_CXX_STANDARD 17)

set(${project}_SOURCES
       main.cpp)

add_subdirectory(mymath)

set(${project}_SOURCE_LIST
       ${${project}_SOURCES})

add_executable(${project}
       ${${project}_SOURCE_LIST})

target_link_libraries(${project} mymath)
```

Тут мы немного добавили переменных окружения, но смотрим на два важных изменения:

• команда add_subdirectory побуждает CMake к незамедлительной обработке указанного файла подпроекта. Так как в CMakeLists.txt нашего подпроекта происходит подготовка статической библиотеки, то в основном проекте мы можем это использовать.
• target_link_libraries компонует библиотеку или исполняемый файл с другими предоставляемыми библиотеками. Первым аргументом данная команда принимает название цели, сгенерированной с помощью команд add_executable или add_library, а последующие аргументы представляют собой названия целей библиотек или полные пути к библиотекам.
Таким образом при сборке основной проект будет знать о других библиотеках.

Изменения main.cpp
Для демонстрации получившегося результата изменим файл main.cpp следующим образом:

```cpp
#include <iostream>
#include "mymath/mymath.h"

int main() {
   setlocale(LC_ALL, "Russian");
   std::cout << "Я умею суммировать! Зацени 1+1=";
   std::cout << mymath::sum(10, 32) << std::endl;

   return 0;
}
```

А как отлаживать получившийся проект?
А об этом смотрите официальные документы:

• CMake projects in Visual Studio
• Quick CMake tutorial (CLion)
• Get started with CMake Tools on Linux (Visual Studio Code)
А что дальше?
Создайте другую статическую библиотеку с другим полезным функционалом и добавьте его в основной проект. Обязательно в исполняемом проекте продемонстрируйте одновременное использование двух статических библиотек.
-->
