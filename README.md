# 1 - Создание и использование статической библиотеки <!-- omit in toc -->

> Лабораторная работа 1 для студентов курса "Программирование на основе классов и шаблонов" 2 семестра кафедры ИУ5 МГТУ им Н.Э. Баумана.

## Содержание <!-- omit in toc -->

- [Цель работы](#цель-работы)
- [Начало работы](#начало-работы)
- [Задание](#задание)
  - [Основное задание](#основное-задание)
  - [Дополнительные задания (по вариантам)](#дополнительные-задания-по-вариантам)
- [Как написать свою библиотеку](#как-написать-свою-библиотеку)
- [Использование библиотек с CMake](#использование-библиотек-с-cmake)
- [Требования к отчёту](#требования-к-отчёту)
- [Вопросы для защиты](#вопросы-для-защиты)

## Цель работы

Целью лабораторной работы является формирование у студентов практических навыков проектирования и использования статических библиотек на языке программирования C++ с применением системы автоматизации сборки CMake, а также освоение принципов разработки кроссплатформенных программных приложений.

В ходе выполнения лабораторной работы студенты должны закрепить знания по модульной организации программного кода и компоновке программных проектов.

## Начало работы

Зайдите в свою локальную директорию с репозиторием для выполнения лабораторных работ. Заберите ветку с соответствующей лабораторной работой из общего репозитория:

```sh
git pull upstream
```

**или**

```sh
git pull upstream lab_1
```

Переключитесь на ветку с текущей лабораторной работой:

```sh
git checkout lab_1
```

Свяжите ветку локального репозитория с вашим удаленным репозиторием:

```sh
git push --set-upstream origin lab_1
```

## Задание

### Основное задание

В рамках лабораторной работы необходимо:

- Создать проект статической библиотеки с использованием системы сборки CMake.

- Реализовать в библиотеке набор функций или класс, обеспечивающий заданную функциональность.

- Создать консольное приложение на языке C++, использующее разработанную статическую библиотеку.

- Подключить библиотеку к приложению и продемонстрировать корректность её работы.

- Обеспечить возможность сборки и запуска проекта в операционных системах семейства Linux.

### Дополнительные задания (по вариантам)

*Вариант 1*
Реализовать в библиотеке операции умножения и деления. Предусмотреть обработку деления на ноль.

*Вариант 2*
Создать библиотеку утилит для обработки аргументов командной строки.

*Вариант 3*
Реализовать в библиотеке функции для работы с массивом чисел (поиск минимального, максимального значения и вычисление среднего).

*Вариант 4*
Добавить в библиотеку функцию возведения числа в степень без использования стандартных библиотечных функций.

*Вариант 5*
Реализовать функции для генерации псевдослучайных чисел и заполнения ими массива.

*Вариант 6*
Реализовать в библиотеке функции для вычисления факториала.

*Вариант 7*
Создать библиотеку для работы со строками (конкатенация, определение длины строки) без использования стандартных библиотечных функций.

*Вариант 8*
Реализовать в библиотеке функции для сортировки массива целых чисел.

*Вариант 9*
Создать библиотеку для статистической обработки данных (среднее значение, медиана, дисперсия).

*Вариант 10*
Добавить в библиотеку функции для поиска элемента в массиве (линейный поиск).

*Вариант 11*
Реализовать библиотеку для работы с датами (сравнение дат, вычисление разницы между датами).

*Вариант 12*
Создать библиотеку для работы с геометрическими фигурами (вычисление площади и периметра).

*Вариант 13*
Реализовать функции для перевода целых чисел из одной системы счисления в другую.

*Вариант 14*
Создать библиотеку утилит для обработки аргументов командной строки.

*Вариант 15*
Реализовать библиотеку вспомогательных функций для работы с файлами (чтение и запись текстовых данных).

*Вариант 16*
Добавить в библиотеку функции для вычисления наибольшего общего делителя и наименьшего общего кратного двух чисел.

*Вариант 17*
Добавить в библиотеку функции для проверки числа на простоту и разложения числа на простые множители.

## Как написать свою библиотеку

1. Разделение кода

*Заголовочный файл (mylib.h).*
В нём объявления функций — что библиотека умеет:

```cpp
#ifndef MYLIB_H
#define MYLIB_H

int add(int a, int b);
int sub(int a, int b);

#endif
```

*Файл реализации (mylib.cpp).*
Здесь реализация функций:

```cpp
#include "mylib.h"

int add(int a, int b) {
    return a + b;
}

int sub(int a, int b) {
    return a - b;
}
```

2. Создание статической библиотеки

*Компиляция в объектный файл:*

```bash
g++ -c mylib.cpp
```

Создаётся файл: `mylib.o`

*Упаковка в статическую библиотеку:*

```bash
ar rcs libmylib.a mylib.o
```

Теперь libmylib.a — статическая библиотека.

3. Используем статическую библиотеку

*Файл программы (main.cpp)*

```cpp
#include "mylib.h"
#include <iostream>

int main() {
    std::cout << add(3, 4);
}
```

*Компиляция программы:*

```bash
g++ main.cpp -L. -lmylib -o app
```

где:

-L. — где искать библиотеку

-lmylib — какую библиотеку подключить

код библиотеки попадёт внутрь app, компоновщик сам выберет подходящий файл.

или принудительно

```bash
g++ main.cpp ./libmylib.a -o app
```

4. Создание динамической библиотеки

*Компиляция с поддержкой динамической загрузки:*

```bash
g++ -fPIC -c mylib.cpp
```

*Создание .so:*

```bash
g++ -shared -o libmylib.so mylib.o
```

Это динамическая библиотека.

5. Использование динамической библиотеки

*Компиляция программы:*

```bash
g++ main.cpp -L. -lmylib -o app
```

Перед запуском:

``` cpp
export LD_LIBRARY_PATH=.
./app
```

(или положить .so в стандартную папку)

## Использование библиотек с CMake

Главная идея CMake:

***CMake не компилирует код сам.
Он генерирует инструкции для компилятора:***

- «что собирать»,
- «из каких файлов»,
- «с какими библиотеками».

```css
project/
│
├── CMakeLists.txt
├── main.cpp
├── mylib.h
└── mylib.cpp
```

*Самый простой CMakeLists.txt*

```bash
cmake_minimum_required(VERSION 3.10)
project(MyProject)

# создаём библиотеку
add_library(mylib mylib.cpp)

# создаём исполняемый файл
add_executable(app main.cpp)

# связываем программу с библиотекой
target_link_libraries(app mylib)
```

*Сборка проекта*

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

Результат:

библиотека собирается автоматически

программа с ней связывается

*Статическая или динамическая библиотека*

По умолчанию CMake решает сам (обычно динамическая).

можно явно указать:
`add_library(mylib STATIC mylib.cpp)`   - статическая
`add_library(mylib SHARED mylib.cpp)`   - динамическая

Где тут -l и -L? - их нет.

CMake:

- сам знает, где лежит библиотека
- сам подставляет -L и -l
- сам следит за порядком линковки

*Как CMake понимает, какие .h подключать*

Если заголовок рядом: `#include "mylib.h"`— всё работает автоматически.

Если в отдельной папке:`target_include_directories(mylib PUBLIC include)` путь, где лежат `.h` файлы библиотеки.

## Требования к отчёту

Отчёт по лабораторной работе должен содержать:

- Титульный лист с указанием дисциплины, номера лабораторной работы, ФИО студента и группы.

- Цель лабораторной работы.

- Формулировку задания и номер варианта.

- Краткие теоретические сведения по теме работы *(выполняются рукописно, разборчивым почерком, на отдельном листе бумаги)*.

- Описание структуры проекта и используемых файлов.

- Исходный код разработанной статической библиотеки и основного приложения.

- Результаты выполнения программы (скриншоты или вывод в консоль).

- Выводы по результатам выполненной работы.

## Вопросы для защиты

- Что такое статическая библиотека и в чём её назначение?

- В чём различие между статическими и динамическими библиотеками?

- На каком этапе происходит подключение статической библиотеки к программе?

- Назначение файлов заголовков в библиотеке.

- Основные команды CMake для создания библиотек и исполняемых файлов.

- Для чего используется команда target_link_libraries?

- Преимущества и недостатки статических библиотек.

- Что означает кроссплатформенность программного обеспечения?
